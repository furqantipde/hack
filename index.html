<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>WebRTC — Host / Viewer (fix black screen)</title>
<style>
  :root { --bg:#071022; --panel:#0b1a2b; --text:#e8f7ff; --muted:#93abc0; --accent:#06b6d4; }
  [data-theme="light"] { --bg:#f6fbff; --panel:#ffffff; --text:#062034; --muted:#5d7682; --accent:#0077a8; }
  *{box-sizing:border-box;font-family:Inter,system-ui,Segoe UI,Roboto,Arial}
  body{margin:0; min-height:100vh; background:linear-gradient(180deg,var(--bg),#041726); color:var(--text); display:flex; align-items:center; justify-content:center; padding:18px;}
  .app{width:100%;max-width:1100px}
  header{display:flex;align-items:center;justify-content:space-between;gap:12px}
  h1{margin:0;font-size:18px}
  .controls{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  input,select,button{padding:8px 10px;border-radius:8px;border:1px solid rgba(255,255,255,0.04); background:transparent;color:var(--text)}
  button{cursor:pointer;font-weight:700}
  button.primary{background:var(--accent);color:#012;border:0}
  .panel{margin-top:14px;background:rgba(255,255,255,0.02);padding:14px;border-radius:12px}
  .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
  .videos{display:flex;gap:12px;flex-wrap:wrap;justify-content:center;margin-top:12px}
  .video-card{width:320px;max-width:100%;background:rgba(255,255,255,0.015);padding:10px;border-radius:10px;display:flex;flex-direction:column;align-items:center;box-shadow:0 6px 20px rgba(0,0,0,0.5)}
  video{width:100%;height:210px;background:#000;border-radius:8px;object-fit:cover}
  .muted{color:var(--muted);font-size:13px}
  #log{margin-top:12px;padding:10px;border-radius:8px;background:rgba(255,255,255,0.02);max-height:160px;overflow:auto;color:#bfe;font-size:13px;white-space:pre-wrap}
  footer{display:flex;justify-content:space-between;align-items:center;margin-top:12px;gap:12px;flex-wrap:wrap;color:var(--muted);font-size:13px}
  @media (max-width:820px){ .video-card{width:100%} header{flex-direction:column;align-items:flex-start} }
</style>
</head>
<body data-theme="dark">
  <div class="app">
    <header>
      <div>
        <h1>WebRTC — Host / Viewer (stable 3 viewers)</h1>
        <div class="muted">Fixes viewer black screen; works on GitHub Pages (HTTPS) or localhost. Optional WebSocket signaling URL for cross-device.</div>
      </div>

      <div class="controls">
        <input id="sigUrl" placeholder="Signaling wss://... (optional)" style="width:280px">
        <input id="roomId" placeholder="Room code (e.g. demo123)" style="width:180px">
        <select id="role">
          <option value="host">Host (share)</option>
          <option value="viewer">Viewer (watch)</option>
        </select>
        <button id="joinBtn" class="primary">Join</button>
        <button id="leaveBtn" style="display:none;">Leave</button>
        <button id="themeBtn">Dark / Light</button>
      </div>
    </header>

    <main class="panel" role="main" aria-live="polite">
      <div class="row" style="justify-content:space-between;align-items:center">
        <div>
          <button id="startCamBtn" style="display:none;" class="">Start Camera</button>
          <button id="stopCamBtn" style="display:none;background:#ff6b6b;color:#fff">Stop Camera</button>
          <span id="status" class="muted" style="margin-left:12px">Not connected</span>
        </div>

        <div class="muted">
          Max viewers: <strong id="maxViewers">3</strong>
        </div>
      </div>

      <section class="videos" id="videos">
        <!-- Local + remote video cards generated here -->
      </section>

      <div id="log" style="display:none;"></div>
    </main>

    <footer>
      <div>Tip: Host must click Start Camera. Viewer doesn't need camera. For cross-device, deploy small signaling server (Node) and paste wss:// URL above.</div>
      <div class="muted">Built for privacy — everyone must allow camera manually.</div>
    </footer>
  </div>

<script>
/* Robust Host->Many-Viewer WebRTC sample
   - Host creates one RTCPeerConnection per viewer and sends offer -> viewer answers.
   - Signaling: WebSocket (if URL provided) OR BroadcastChannel fallback (same-origin only).
   - Ensures remote video .play() after user gesture, attaches tracks reliably.
   - Limits to MAX_VIEWERS for stability.
*/

const MAX_VIEWERS = 3;

const joinBtn = document.getElementById('joinBtn');
const leaveBtn = document.getElementById('leaveBtn');
const startCamBtn = document.getElementById('startCamBtn');
const stopCamBtn = document.getElementById('stopCamBtn');
const roomInput = document.getElementById('roomId');
const roleSelect = document.getElementById('role');
const sigInput = document.getElementById('sigUrl');
const statusEl = document.getElementById('status');
const videosEl = document.getElementById('videos');
const themeBtn = document.getElementById('themeBtn');
const logEl = document.getElementById('log');
const maxViewersEl = document.getElementById('maxViewers');

let localId = null;
let role = null;
let room = null;
let localStream = null;
let signaling = null;   // { send(obj) } wrapper for WS or BroadcastChannel
let isWS = false;
let peers = {};        // peers[peerId] = { pc, createdAt }
let joined = false;

maxViewersEl.textContent = MAX_VIEWERS;

// ---------- utilities ----------
function genId(len=8){ return Math.random().toString(36).slice(2,2+len); }
function now(){ return new Date().toLocaleTimeString(); }
function log(...parts){ if(logEl.style.display==='none') return; logEl.textContent += `[${now()}] ` + parts.join(' ') + '\\n'; logEl.scrollTop = logEl.scrollHeight; }
function setStatus(s){ statusEl.textContent = s; log('status', s); }

// ---------- UI helpers ----------
function createVideoCard(id, title, muted=false, isLocal=false){
  // If already exists, return video element
  let existing = document.getElementById('card-' + id);
  if(existing) return existing.querySelector('video');

  const card = document.createElement('div');
  card.className = 'video-card';
  card.id = 'card-' + id;

  const h = document.createElement('div');
  h.style.fontWeight = '700';
  h.style.marginBottom = '6px';
  h.textContent = title;

  const vid = document.createElement('video');
  vid.id = 'video-' + id;
  vid.autoplay = true;
  vid.playsInline = true;
  vid.muted = !!muted;
  // don't call play() here — will call after srcObject is set and user gesture happened

  const meta = document.createElement('div');
  meta.className = 'muted';
  meta.style.marginTop = '6px';
  meta.textContent = isLocal ? 'Local preview (muted)' : 'Remote';

  card.appendChild(h);
  card.appendChild(vid);
  card.appendChild(meta);

  videosEl.appendChild(card);
  return vid;
}

function removeVideoCard(id){
  const card = document.getElementById('card-' + id);
  if(card) card.remove();
}

// ---------- Signaling layer ----------
function connectSignaling(url){
  // Cleanup previous
  if(signaling && signaling.close) {
    try { signaling.close(); } catch(e) {}
    signaling = null;
  }
  if(url){
    // attempt WebSocket
    try {
      const ws = new WebSocket(url);
      ws.addEventListener('open', ()=> {
        isWS = true;
        setStatus('Signaling WS connected');
        log('WS connected to', url);
        // Register presence
        sendSignal({ type:'join', room, from: localId, role });
      });
      ws.addEventListener('message', ev => {
        let obj;
        try { obj = JSON.parse(ev.data); } catch(e){ return; }
        onSignalReceived(obj);
      });
      ws.addEventListener('close', ()=> setStatus('Signaling WS closed'));
      ws.addEventListener('error', (e)=> { setStatus('Signaling WS error'); log('ws error', e); });
      signaling = { send: (obj)=> { if(ws.readyState===WebSocket.OPEN) ws.send(JSON.stringify(obj)); }, close: ()=> ws.close() };
      return;
    } catch(err) {
      log('WS connect failed', err);
    }
  }

  // Fallback: BroadcastChannel (same-origin tabs)
  if ('BroadcastChannel' in window ) {
    const chan = new BroadcastChannel('webrtc_room_' + room);
    chan.onmessage = (e)=> onSignalReceived(e.data);
    signaling = { send: (obj)=> chan.postMessage(obj), close: ()=> chan.close() };
    isWS = false;
    setStatus('Using BroadcastChannel (same-origin)');
    log('Using BroadcastChannel for local signaling. Works only same-origin contexts.');
    // announce presence
    setTimeout(()=> sendSignal({ type:'join', room, from: localId, role }), 200);
    return;
  }

  // No signaling available
  alert('No signaling available (provide a WebSocket URL or run on same origin supporting BroadcastChannel).');
  throw new Error('No signaling');
}

function sendSignal(obj){
  if(!signaling) return;
  obj.room = room;
  obj.from = localId;
  try {
    signaling.send(obj);
  } catch(e) {
    log('sendSignal error', e);
  }
}

// ---------- Signaling handler ----------
async function onSignalReceived(msg){
  if(!msg || msg.room !== room) return;
  if(msg.from === localId) return; // ignore our own messages
  log('signal', msg.type, 'from', msg.from, 'to', msg.to || 'all');

  switch(msg.type){
    case 'join':
      // viewer announced join — only Host cares and will create offer if camera running
      if(role === 'host' && msg.role === 'viewer'){
        // limit viewers
        if(Object.keys(peers).length >= MAX_VIEWERS){
          log('max viewers reached — ignoring', msg.from);
          return;
        }
        await hostCreateOfferForViewer(msg.from);
      }
      break;

    case 'offer':
      // viewer receives offer from host? Our chosen flow: host sends offer to viewer.
      if(role === 'viewer' && msg.to === localId){
        await viewerHandleOffer(msg.from, msg.data);
      }
      break;

    case 'answer':
      // host receives answer from viewer
      if(role === 'host' && peers[msg.from] && peers[msg.from].pc){
        try {
          await peers[msg.from].pc.setRemoteDescription(new RTCSessionDescription(msg.data));
          log('Host set remote desc for', msg.from);
        } catch(e){ log('Error setRemoteDescription answer', e); }
      }
      break;

    case 'ice':
      // add candidate to the appropriate pc
      const src = msg.from;
      if(peers[src] && peers[src].pc){
        try { await peers[src].pc.addIceCandidate(new RTCIceCandidate(msg.data)); } catch(e){ log('ice add error', e); }
      } else {
        log('ice for unknown peer', src);
      }
      break;

    case 'leave':
      removePeer(msg.from);
      break;

    default:
      log('unknown signal type', msg.type);
  }
}

// ---------- Host: create offer to viewer ----------
async function hostCreateOfferForViewer(viewerId){
  if(!localStream){
    log('Host has no local stream; cannot create offer for', viewerId);
    return;
  }
  log('Host creating offer for viewer', viewerId);
  const pc = new RTCPeerConnection({ iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] });
  peers[viewerId] = { pc, createdAt: Date.now() };

  // add tracks
  localStream.getTracks().forEach(track => pc.addTrack(track, localStream));

  // ICE -> send to viewer
  pc.onicecandidate = (e) => { if(e.candidate) sendSignal({ type:'ice', to: viewerId, data: e.candidate }); };

  // connection state handler
  pc.onconnectionstatechange = () => {
    log('pc state', viewerId, pc.connectionState);
    if(pc.connectionState === 'failed' || pc.connectionState === 'disconnected' || pc.connectionState === 'closed'){
      removePeer(viewerId);
    }
  };

  // Create offer
  try {
    const offer = await pc.createOffer();
    await pc.setLocalDescription(offer);
    // send this offer targeted to viewerId (viewer will respond back)
    sendSignal({ type:'offer', to: viewerId, data: offer });
    log('Host sent offer to', viewerId);
  } catch (e) {
    log('host createOffer error', e);
  }
}

// ---------- Viewer: handle incoming offer ----------
async function viewerHandleOffer(fromHostId, offer){
  log('Viewer handling offer from', fromHostId);
  // create pc
  const pc = new RTCPeerConnection({ iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] });
  peers[fromHostId] = { pc, createdAt: Date.now() };

  // when track arrives attach to video
  pc.ontrack = (e) => {
    log('Viewer ontrack from', fromHostId);
    const vid = createVideoCard('remote-' + fromHostId, 'Host video', false);
    // attach stream and try to play (user gesture already happened because Join was clicked)
    vid.srcObject = e.streams[0];
    try { vid.play().catch(()=>{}); } catch(e){}
  };

  pc.onicecandidate = (e) => { if(e.candidate) sendSignal({ type:'ice', to: fromHostId, data: e.candidate }); };

  try {
    await pc.setRemoteDescription(new RTCSessionDescription(offer));
    const answer = await pc.createAnswer();
    await pc.setLocalDescription(answer);
    sendSignal({ type:'answer', to: fromHostId, data: answer });
    log('Viewer sent answer to host', fromHostId);
  } catch(e) {
    log('viewer handleOffer error', e);
  }

  pc.onconnectionstatechange = ()=> {
    log('viewer pc state', fromHostId, pc.connectionState);
    if(pc.connectionState === 'failed' || pc.connectionState === 'disconnected' || pc.connectionState === 'closed'){
      removePeer(fromHostId);
    }
  };
}

// ---------- remove peer ----------
function removePeer(peerId){
  if(peers[peerId]){
    try { peers[peerId].pc.close(); } catch(e){}
    delete peers[peerId];
    removeVideoCard('remote-' + peerId);
    log('removed peer', peerId);
  }
}

// ---------- start/stop camera (host) ----------
async function startLocalCamera(){
  if(!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia){
    alert('Camera API not supported. Use HTTPS or modern browser.');
    return;
  }
  try {
    localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
    const video = createVideoCard('local', 'You (host)', true, true);
    video.srcObject = localStream;
    try { video.play().catch(()=>{}); } catch(e){}
    startCamBtn.style.display = 'none';
    stopCamBtn.style.display = '';
    setStatus('Local camera on');
    // If any viewers already joined and signaled, create offers for them
    // (some viewers may have joined before host started camera)
    // send 'join' to prompt hostCreateOfferForViewer logic on host side
    // Actually, since this is host, check existing viewers (if signaling has messages queued, they'll have been processed)
  } catch (e) {
    alert('Could not start camera: ' + (e.message || e));
    log('startLocalCamera error', e);
  }
}

function stopLocalCamera(){
  if(localStream){
    localStream.getTracks().forEach(t=>t.stop());
    localStream = null;
  }
  removeVideoCard('local');
  stopCamBtn.style.display = 'none';
  if(role === 'host') startCamBtn.style.display = '';
  setStatus('Local camera stopped');
  // optionally notify viewers that host is offline
  sendSignal({ type: 'leave' });
}

// ---------- join / leave flow ----------
function attachUIHandlers(){
  joinBtn.onclick = async () => {
    if(joined) return;
    room = (roomInput.value || '').trim();
    role = roleSelect.value;
    if(!room) { alert('Enter a room code'); return; }
    localId = genId();
    try {
      connectSignaling(sigInput.value.trim());
    } catch(e) {
      console.error('signaling failed', e);
      return;
    }
    // mark joined and update UI
    joined = true;
    joinBtn.style.display = 'none';
    leaveBtn.style.display = '';
    setStatus(`Joined room ${room} as ${role} (${localId})`);
    // If host: show start camera button
    if(role === 'host'){
      startCamBtn.style.display = '';
    } else {
      // viewer: announce presence to host
      // viewer does not need to start camera; just announce join so host can create offer
      setTimeout(()=> sendSignal({ type: 'join', role: 'viewer' }), 300);
    }
  };

  leaveBtn.onclick = () => {
    // notify others
    sendSignal({ type: 'leave' });
    // cleanup
    Object.keys(peers).forEach(id => removePeer(id));
    if(localStream){ localStream.getTracks().forEach(t=>t.stop()); localStream=null; removeVideoCard('local'); }
    if(signaling && signaling.close) try{ signaling.close(); }catch(e){}
    signaling = null;
    joined = false;
    joinBtn.style.display = '';
    leaveBtn.style.display = 'none';
    startCamBtn.style.display = 'none';
    stopCamBtn.style.display = 'none';
    setStatus('Left room');
  };

  startCamBtn.onclick = startLocalCamera;
  stopCamBtn.onclick = stopLocalCamera;

  themeBtn.onclick = ()=> {
    const el = document.body;
    const cur = el.getAttribute('data-theme') || 'dark';
    const next = cur === 'dark' ? 'light' : 'dark';
    el.setAttribute('data-theme', next);
  };
}

// ---------- init UI skeleton ----------
function initUI(){
  videosEl.innerHTML = ''; // placeholder; will append local + remote cards dynamically
  // small hint card
  const hint = document.createElement('div');
  hint.className = 'video-card';
  hint.style.textAlign='center';
  hint.innerHTML = '<div style="font-weight:700;margin-bottom:6px">Waiting for streams</div><div class="muted">Join as Host (Start Camera) or Viewer (Join)</div>';
  videosEl.appendChild(hint);
}

attachUIHandlers();
initUI();
logEl.style.display='block';
log('UI ready — paste signaling WS or use BroadcastChannel (no server) for same-origin demos.');
</script>
</body>
</html>

